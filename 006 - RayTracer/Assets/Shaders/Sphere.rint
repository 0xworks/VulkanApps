#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_NV_ray_tracing : require

#include "Bindings.glsl"
#include "Material.glsl"
#include "Random.glsl"
#include "UniformBufferObject.glsl"

layout(set = 0, binding = BINDING_SPHEREBUFFER) readonly buffer SphereArray { vec4 spheres[]; };
layout(set = 0, binding = BINDING_MATERIALBUFFER) readonly buffer MaterialArray { Material materials[]; };
layout(set = 0, binding = BINDING_UNIFORMBUFFER) readonly uniform UBO {
   UniformBufferObject ubo;
};

hitAttributeNV vec4 unused;   // you must declare a hitAttributeNV otherwise the shader does not work properly!

void main() {
   const vec4 sphere = spheres[gl_InstanceCustomIndexNV];
   const vec3 centre = sphere.xyz;
   const float radius = sphere.w;

   const vec3 origin = gl_WorldRayOriginNV;
   const vec3 direction = gl_WorldRayDirectionNV;
   const float tMin = gl_RayTminNV;
   const float tMax = gl_RayTmaxNV;

   // https://en.wikipedia.org/wiki/Quadratic_formula

   const vec3 oc = origin - centre;
   const float a = dot(direction, direction);
   const float b = dot(oc, direction);
   const float c = dot(oc, oc) - radius * radius;
   const float discriminant = b * b - a * c;

   if (discriminant >= 0) {
      float t1 = (-b - sqrt(discriminant)) / a;
      float t2 = (-b + sqrt(discriminant)) / a;

      Material material = materials[gl_InstanceCustomIndexNV];
      if(material.type == MATERIAL_SMOKE) {
         uint seed = InitRandomSeed(
            InitRandomSeed(
               InitRandomSeed(
                  InitRandomSeed(
                     InitRandomSeed(gl_LaunchIDNV.x, gl_LaunchIDNV.y),
                     uint(gl_WorldRayOriginNV.x)
                  ),
                  uint(gl_WorldRayOriginNV.y)
               ),
               uint(gl_WorldRayOriginNV.z)
            ),
            ubo.accumulatedFrameCount
         );
         const float hitDistance = max(t1, tMin) + material.materialParameter1 * log(RandomFloat(seed));
         if ((hitDistance <= t2) && (t2 < tMax)) {
            reportIntersectionNV(hitDistance, 0);
         }
      } else {
         if ((tMin <= t1 && t1 < tMax) || (tMin <= t2 && t2 < tMax)) {
            reportIntersectionNV((tMin <= t1 && t1 < tMax) ? t1 : t2, 0);
         }
      }
   }
}
